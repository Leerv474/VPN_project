#include "../include/vpn_client.h"
#include <arpa/inet.h>
#include <cstdint>
#include <cstdio>
#include <stdexcept>
#include <thread>
#include <vector>
#include <iomanip>

VpnClient::VpnClient(const std::string& tunName, const std::string& tunIp, const int tunNetmask,
                     const std::string& serverIp, uint16_t serverPort, size_t bufferSize, const std::string& privateKey,
                     const std::string& serverPublicKey)
    : serverIp(serverIp), serverPort(serverPort), buffer(bufferSize), tunDevice(tunName, tunIp, tunNetmask),
      serverPublicKey(serverPublicKey), authenticator(privateKey), tunIp(tunIp) {

    socket.bind("0.0.0.0", 0);
    epollManager.addFd(tunDevice.getFd(), EPOLLIN);
    epollManager.addFd(socket.getFd(), EPOLLIN);
}

void VpnClient::eventLoop() {
    constexpr int MAX_EVENTS = 10;
    epoll_event events[MAX_EVENTS];

    std::this_thread::sleep_for(std::chrono::seconds(1));

    challenge = authenticator.generateChallenge();
    uint32_t vpnIp = inet_addr(this->tunIp.c_str());
    challenge.insert(challenge.begin(), reinterpret_cast<uint8_t*>(&vpnIp),
                           reinterpret_cast<uint8_t*>(&vpnIp) + sizeof(vpnIp));
    challenge.insert(challenge.begin(), static_cast<uint8_t>(MessageType::CLIENT_CHALLENGE));
    ssize_t nsend = socket.sendTo(challenge.data(), challenge.size(), this->serverIp, this->serverPort);

    if (nsend <= 0) {
        std::runtime_error("Failed to send authentication challenge");
    }

    while (runEventLoop) {
        int n = epollManager.wait(events, MAX_EVENTS, -1);

        for (int i = 0; i < n; ++i) {
            int fd = events[i].data.fd;

            if (fd == tunDevice.getFd()) {
                handleRead();
            } else if (fd == socket.getFd()) {
                handleSend();
            }
        }
    }
}

void VpnClient::handleRead() {
    ssize_t len = tunDevice.readPacket(buffer.data(), buffer.size());
    if (len > 0) {
        buffer.insert(buffer.begin(), static_cast<uint8_t>(MessageType::VPN_PACKET));
        socket.sendTo(buffer.data(), len, serverIp, serverPort);
    }
    // std::cout << "[TUN] Read " << len << " bytes, sending to server " << serverIp << ":" << serverPort << std::endl;
}

void VpnClient::handleSend() {
    std::string srcIp;
    uint16_t srcPort;
    ssize_t nrecv = socket.recvFrom(buffer.data(), buffer.size(), srcIp, srcPort);
    uint32_t vpnIp;
    if (nrecv > 0) {
        MessageType type = static_cast<MessageType>(buffer[0]);
        std::vector<uint8_t> payload(buffer.begin() + 1, buffer.begin() + nrecv);
        switch (type) {
        case MessageType::SERVER_RESPONSE:
            if (!authenticator.verifyChallenge(serverPublicKey, this->challenge, payload)) {
                std::cout << serverPublicKey << '\n';
                throw std::runtime_error("Client challenge failed");
            }
            std::cout << "Challenge succeeded\n";
            break;
        case MessageType::SERVER_CHALLENGE:
            buffer = authenticator.signChallenge(payload);
            vpnIp = inet_addr(this->tunIp.c_str());
            buffer.insert(buffer.begin(), reinterpret_cast<uint8_t*>(&vpnIp),
                          reinterpret_cast<uint8_t*>(&vpnIp) + sizeof(vpnIp));
            buffer.insert(buffer.begin(), static_cast<uint8_t>(MessageType::CLIENT_RESPONSE));
            socket.sendTo(buffer.data(), buffer.size(), this->serverIp, this->serverPort);
            break;
        case MessageType::VPN_PACKET:
            tunDevice.writePacket(payload.data(), nrecv);
            break;
        default:
            std::cout << "Unknown package type\n";
            break;
        }
    }
}
